<!doctype HTML>
<html>

<head>
<script type="text/javascript">
/*实战翻转字符串算法

你可以先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，然后把数组转化成字符串。

*/
function reverseString(str) {
  str = str.split("");
  str.reverse();
  str = str.join("");
return str;
}

reverseString("hello");
/*计算所提供整数的阶乘。

如果使用字母n代表一个整数，则阶乘是所有小于或等于n的整数的乘积。

阶乘通常简写成 n!*/
function factorialize(num) {
  var j = 1;
 for(var i=num;i>1;i--){
   j = j * i;
 }
return j;
}

factorialize(5);
/*如果给定的字符串是回文，返回true，反之，返回false。

palindrome(回文)是指一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样。*/
function palindrome(str) {
// Good luck!
  var re = /([^a-zA-Z0-9]*)/gi;
  str = str.replace(re,"");
  str = str.toLowerCase();
  var s = str.split("").reverse().join("");
  if (s != str){
    return false;
  }
return true;
}

palindrome("eye");
/*返回提供的句子中最长的单词的长度。

返回值应该是一个数字。*/
function findLongestWord(str) {
  var a = str.split(" ");
  var j = 0; 
  for(var i=0;i<a.length;i++){
     j = j>a[i].length?j:a[i].length;
   }
return j;
}

findLongestWord("The quick brown fox jumped over the lazy dog");

/*返回一个字符串,确保字符串的每个单词首字母都大写，其余部分小写。

像'the'和'of'这样的连接符同理。*/
function titleCase(str) {
  str = str.toLowerCase();
  	str = str.split(" ");
  for(var i=0;i<str.length;i++){
    var s = str[i] ;
   str[i] =  s.charAt(0).toUpperCase()+s.substring(1);
  }
  str = str.join(" ");
  
return str;
}

titleCase("I'm a little tea pot");
/*   在右边的大数组中包含了4个小数组，请分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新的数组。

提示：你可以用for循环来迭代数组，并通过arr[i]的方式来访问数组的每个元素。*/
function largestOfFour(arr) {
// Yu can do this!
  var s = [];
  for(var i=0;i<arr.length;i++){
    var tempArr = arr[i];
	console.log(tempArr);
	var tempVar = 0;
	for(var j=0;j<tempArr.length;j++){
		tempVar = tempArr[j]>tempVar?tempArr[j]:tempVar;
	}

    s.push(tempVar);
		console.log(s);
  }
return s;
}

largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);
/*检查一个字符串(str)是否以指定的字符串(target)结尾。

如果是，返回true;如果不是，返回false。

这个挑战可以通过在ES2015中引入的.endsWith()方法来解决。但是出于这个挑战的目的，我们希望您使用JavaScript子串方法之一。*/
function confirmEnding(str, target) {
// "Never give up and good luck will find you."
// -- Falcor
  
var a = target==str.substring(str.length-target.length)?true:false; 
  
return a;
}

confirmEnding("Bastian", "n");
/**/
function repeat(str, num) {
// repeat after me
  var s="";
 while(num-->0){
   s+=str;
 }
return s;
}

repeat("abc", 3);
/*循环拼接一个指定的字符串 num次，如果num是一个负数,则返回一个空字符串。*/
function truncate(str, num) {
// Clear out that junk in your trunk
  if(num>3 && num<str.length){
    str = str.slice(0,num-3)+"...";
  }else if(num<=3){
    str=str.slice(0,num)+"...";
  }
return str;
}

truncate("A-tisket a-tasket A green and yellow basket", 11);
/* 如果字符串的长度比给定的参数num长，则把多余的部分用...来表示。

切记，插入到字符串尾部的三个点号也会计入字符串的长度。

然而，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。*/
function chunk(arr, size) {
// Break it up.
var l = arr.length;
var a = Math.ceil(l/size);
var ary = [];
for(var i=0;i<a;i++){
	ary[i]=[];
	var k = 0;
	var z = ((i+1)*size>l?l:(i+1)*size);
	for(var j=i*size;j<z;j++){
		ary[i][k++] = arr[j];
	}
}
return ary;
}

chunk(["a", "b", "c", "d"], 2);

/*   编写一个函数,把一个数组arr按照指定的数组大小size分割成若干个数组块。

例如:chunk([1,2,3,4],2)=[[1,2],[3,4]];

chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]];*/
function chunk(arr, size) {
// Break it up.
var l = arr.length;
var a = Math.ceil(l/size);
var ary = [];
console.log("a="+a);
for(var i=0;i<a;i++){
	ary[i]=[];
	var k = 0;
	var z = ((i+1)*size>l?l:(i+1)*size);
	console.log("z="+z);
	for(var j=i*size;j<z;j++){
		ary[i][k++] = arr[j];
	}
}
return ary;
}
console.log(chunk(["a", "b", "c", "d"], 2));
console.log(chunk([0, 1, 2, 3, 4, 5], 4));

/*返回一个数组被截断n个元素后还剩余的元素，从索引0开始截断。*/

function slasher(arr, howMany) {
// it doesn't always pay to be first

	  arr.splice(0,howMany);

return arr;
}

slasher([1, 2, 3], 2);


/* 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，则函数返回true。

举例，["hello", "Hello"]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。

["hello", "hey"]应该返回false，因为字符串"hello"并不包含字符"y"。

["Alien", "line"]应该返回true，因为"line"中所有字符都可以在"Alien"找到。*/

function mutation(arr) {
 var a = arr[0].toLowerCase();
  var b = arr[1].toLowerCase();
  var arr1 = b.split("");
  var flag = true;
for(var i = 0;i<arr1.length;i++){
	if(a.indexOf(arr1[i].toLowerCase())==-1){
	flag=false;
	break;
	}
	}
	return flag;
}

console.log(mutation(["hello", "hey"]));
console.log(mutation(["zyxwvutsrqponmlkjihgfedcba", "qrstu"]));

/*删除数组中的所有的假值。

在JavaScript中，假值有false、null、0、""、undefined 和 NaN。*/
function bouncer(arr) {
// Don't show a false ID to this bouncer.
var a = Array();
for(var i=0;i<arr.length;i++){
	if(Object.is(arr[i],false) || Object.is(arr[i],null) || Object.is(arr[i],0) || Object.is(arr[i],"") || Object.is(arr[i],undefined) || Object.is(arr[i], NaN)){
		continue;
	}
	a.push(arr[i]);

}

return a;
}

bouncer([7, "ate", "", false, 9]);
console.log(bouncer([false, null, 0, NaN, undefined, ""]));
console.log(bouncer([1, null, NaN, 2, undefined]) );


/* 实现一个 destroyer 函数，第一个参数是初始数组，后跟一个或多个参数。从初始数组中删除与这些参数具有相同值的所有元素。*/

function destroyer(arr) {
// Remove all the values
var a = Array.prototype.slice.call(arguments);
console.log(a.length);
var temp = a[0];
var ary = [];
for(var i=0;i<temp.length;i++){
var flag=true;
	for(var j=1;j<a.length;j++){
		if(temp[i]==a[j]){
			flag=false;
			break;
		}
	}
	if(flag){
		ary.push(temp[i]);
	}
}
return ary;
}

console.log(destroyer([1, 2, 3, 1, 2, 3], 2, 3));

/* 先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。

举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。

同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。*/

function where(arr, num) {
// Find my place in this sorted array.
if(arr.indexOf(num)!=-1){
	arr = arr.sort(function compareNumber(a,b){return a-b;});
	console.log(arr);
	return arr.indexOf(num);
}else{
arr.push(num);
arr = arr.sort(function compareNumber(a,b){return a-b;});
console.log(arr);
num = arr.indexOf(num);
return num;
}
}

console.log(where([40, 60], 50));
console.log(where([5, 3, 20, 3], 5));

/*下面我们来介绍著名的凯撒密码Caesar cipher，又叫移位密码。

移位密码也就是密码中的字母会按照指定的数量来做移位。

一个常见的案例就是ROT13密码，字母会移位13个位置。由'A' ↔ 'N', 'B' ↔'O'，以此类推。

写一个ROT13函数，实现输入加密字符串，输出解密字符串。

所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，就跳过它们。*/

function rot13(str) { // LBH QVQ VG!

var s = "";
for(var i=0;i<str.length;i++){
var cod = str.charCodeAt(i);
	console.log(str.charCodeAt(i));
	if(cod>=65 && cod<65+26){
		s+=String.fromCharCode(cod+13>90?cod+13-91+65:cod+13);
	}else{
		s+=String.fromCharCode(cod);
		continue;
	}
}
return s;
}

// Change the inputs below to test
console.log(rot13("SERR PBQR PNZC"));
console.log(String.fromCharCode(90));

/*我们会传递给你一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。

最小的数字并非总在最前面。
*/
function sumAll(arr) {
arr = arr.sort(function a(b,c){return b-c;});
console.log(arr);
var sum=0;
var a = arr[0];
var b = arr[1];
sum+=a;
while(a<b){
	sum+=(a+=1);
	
}



return sum;
}

console.log(sumAll([1, 4]));

/*比较两个数组，然后返回一个新数组，该数组的元素为两个给定数组中所有独有的数组元素。换言之，返回两个数组的差异。
*/

function diff(arr1, arr2) {
var newArr = [];
// Same, same; but different.
for(var i=0;i<arr1.length;i++){
	if(arr2.indexOf(arr1[i])==-1){newArr.push(arr1[i]);}
}
for(var i=0;i<arr2.length;i++){
	if(arr1.indexOf(arr2[i])==-1){newArr.push(arr2[i]);}
}
return newArr;
}

console.log(diff([1, 2, 3, 5], [1, 2, 3, 4, 5]));

 /*写一个 function方法，它遍历一个对象数组（第一个参数）并返回一个包含相匹配的属性-值对（第二个参数）的所有对象的数组。如果返回的数组中包含 source 对象的属性-值对，那么此对象的每一个属性-值对都必须存在于 collection 的对象中。

例如，如果第一个参数是 [{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }]，第二个参数是 { last: "Capulet" }，那么你必须从数组（第一个参数）返回其中的第三个对象，因为它包含了作为第二个参数传递的属性-值对。*/




</script>

</head>
<body></body>

</html>